lines(x1, y1, lty=2, lwd=2, col="blue")
hist(ch.4.mean, prob=T, main="표본 크기 : 4",
ylab="", xlab="", col="orange", border="red")
x2 <- seq(min(ch.4.mean), max(ch.4.mean), length=1000)
y2 <- dnorm(x=x2, mean=m1, sd=s1/sqrt(4))
lines(x2, y2, lty=2, lwd=2, col="blue")
hist(ch.16.mean, prob=T, main="표본 크기 : 16",
ylab="", xlab="", col="orange", border="red")
x3 <- seq(min(ch.16.mean), max(ch.16.mean), length=1000)
y3 <- dnorm(x=x3, mean=m1, sd=s1/sqrt(16))
lines(x3, y3, lty=2, lwd=2, col="blue")
hist(ch.64.mean, prob=T, main="표본 크기 : 64",
ylab="", xlab="", col="orange", border="red")
x4 <- seq(min(ch.64.mean), max(ch.64.mean), length=1000)
y4 <- dnorm(x=x4, mean=m1, sd=s1/sqrt(64))
lines(x4, y4, lty=2, lwd=2, col="blue")
mtext("Chi Square 표본평균 분포(df=10인 경우)", outer = TRUE, cex = 1.2)
n <- 1000
df <- 30
t.2.mean <- rep(NA, n)
t.4.mean <- rep(NA, n)
t.8.mean <- rep(NA, n)
t.16.mean <- rep(NA, n)
for(i in 1:n) {
t.2.mean[i] <- mean(rt(2, df=df))
t.4.mean[i] <- mean(rt(4, df=df))
t.8.mean[i] <- mean(rt(8, df=df))
t.16.mean[i] <- mean(rt(16, df=df))
}
m <- 0
s <- sqrt(df / (df - 2))
par(mfrow=c(2,2), oma = c(0, 0, 2, 0))
hist(t.2.mean, prob=T, main="표본 크기 : 2",
ylab="", xlab="", col="orange", border="red")
x1 <- seq(min(t.2.mean), max(t.2.mean), length=1000)
y1 <- dnorm(x=x1, mean=m, sd=s/sqrt(2))
lines(x1, y1, lty=2, lwd=2, col="blue")
hist(t.4.mean, prob=T, main="표본 크기 : 4",
ylab="", xlab="", col="orange", border="red")
x2 <- seq(min(t.4.mean), max(t.4.mean), length=1000)
y2 <- dnorm(x=x2, mean=m, sd=s/sqrt(4))
lines(x2, y2, lty=2, lwd=2, col="blue")
hist(t.8.mean, prob=T, main="표본 크기 : 8",
ylab="", xlab="", col="orange", border="red")
x3 <- seq(min(t.8.mean), max(t.8.mean), length=1000)
y3 <- dnorm(x=x3, mean=m, sd=s/sqrt(8))
lines(x3, y3, lty=2, lwd=2, col="blue")
hist(t.16.mean, prob=T, main="표본 크기 : 16",
xlim=c(-2,2), ylim=c(0,0.9),
ylab="", xlab="", col="orange", border="red")
x4 <- seq(min(t.16.mean), max(t.16.mean), length=1000)
y4 <- dnorm(x=x4, mean=m, sd=s/sqrt(16))
lines(x4, y4, lty=2, lwd=2, col="blue")
mtext("T 표본평균 분포(df=30인 경우)", outer = TRUE, cex = 1.2)
n2 <- 1000
df01 <- 10; df02 <- 20
f.2.mean <- rep(NA, n2)
f.4.mean <- rep(NA, n2)
f.8.mean <- rep(NA, n2)
f.16.mean <- rep(NA, n2)
for(i in 1:n2) {
f.2.mean[i] <- mean(rf(2, df1=df01, df2=df02))
f.4.mean[i] <- mean(rf(4, df1=df01, df2=df02))
f.8.mean[i] <- mean(rf(8, df1=df01, df2=df02))
f.16.mean[i] <- mean(rf(16, df1=df01, df2=df02))
}
m2 <- df02 / (df02 - 2)
s2 <- sqrt(2 * df02^2 * (df01+df02-2) /(df01 * (df02-2)^2 * (df02-4)))
par(mfrow=c(2,2), oma = c(0, 0, 2, 0))
hist(f.2.mean, prob=T, main="표본 크기 : 2",
xlim=c(0,10),
ylab="", xlab="", col="orange", border="red")
x1 <- seq(min(f.4.mean), max(f.4.mean), length=1000)
y1 <- dnorm(x=x1, mean=m2, sd=s2/sqrt(4))
lines(x1, y1, lty=2, lwd=2, col="blue")
hist(f.4.mean, prob=T, main="표본 크기 : 4",
xlim=c(0,6),
ylab="", xlab="", col="orange", border="red")
x2 <- seq(min(f.4.mean), max(f.4.mean), length=1000)
y2 <- dnorm(x=x2, mean=m2, sd=s2/sqrt(4))
lines(x2, y2, lty=2, lwd=2, col="blue")
hist(f.8.mean, prob=T, main="표본 크기 : 8",
xlim=c(0.4,4),
ylab="", xlab="", col="orange", border="red")
x3 <- seq(min(f.8.mean), max(f.8.mean), length=1000)
y3 <- dnorm(x=x3, mean=m2, sd=s2/sqrt(8))
lines(x3, y3, lty=2, lwd=2, col="blue")
hist(f.16.mean, prob=T, main="표본 크기 : 16",
xlim=c(0.8,3),
ylab="", xlab="", col="orange", border="red")
x4 <- seq(min(f.16.mean), max(f.16.mean), length=1000)
y4 <- dnorm(x=x4, mean=m2, sd=s2/sqrt(16))
lines(x4, y4, lty=2, lwd=2, col="blue")
mtext("F 표본평균 분포(df1=3, df5=5인 경우)", outer = TRUE, cex = 1.2)
mean.seq <- function(x) {
n <- length(x)
sum <- 0
n2 <- 0
for (i in 1:n) {
newx <- i * x[i]
sum <- sum + newx
n2 <- n2 + i
}
return(sum / n2)
}
y1 <- rep(NA, 1000)
y2 <- rep(NA, 1000)
for(i in 1:1000) {
smp <- rnorm(3)
y1[i] <- mean(smp)
y2[i] <- mean.seq(smp)
}
n1 <- length(y1[(y2 > -0.1) & (y1 < 0.1)])
n2 <- length(y2[(y2 > -0.1) & (y2 < 0.1)])
data.frame(mean=mean(y1), var = var(y1),n=n1)
data.frame(mean=mean(y2), var = var(y2),n=n2)
par(mfrow=c(1,2))
hist(y1,probability = T,col = "black")
hist(y1,probability = T,col = "black",border = "white")
hist(y2, probability = T,col = "white",border = "black")
hist(y1,probability = T,col = "black",border = "white")
hist(y1,probability = T,col = "black",border = "white")
hist(y2, probability = T,col = "white",border = "black")
par(mfrow=c(1,2))
hist(y1,probability = T,col = "black",border = "white")
hist(y2, probability = T,col = "white",border = "black")
x <- seq(-3,3,by=0.01)
y <- dnorm(x)
y.1 <- dnorm(x, sd = sqrt(1/3))
y.2 <- dnorm(x, sd = sqrt(7/18))
pnorm(0.1, sd(sqrt(1/3)) - pnorm(-0.1,sd=sqrt(1/3)))
pnorm(0.1, sd(sqrt(7/18)) - pnorm(-0.1,sd=sqrt(7/18)))
plot(x,y,axes = F)
lines(x,y1,col="red")
lines(x,y.1,col="red")
lines(x,y.2,col="green")
plot(x,y,axes = F,ylim = c(0,0.8))
lines(x,y.1,col="red")
lines(x,y.2,col="green")
axis(1)
# 5-3
library(prob)
n <- 3
smps.all <- rolldie(n)
str( smps.all, n=3)
head(smps.all,n=3)
p.even <- function(x , s,size=3) {
return(sum(is.even(x))/ s.size)
}
phat <- apply(smps.all,1,p.even)
mean(phat)
n <- 3
smps.all <- rolldie(n)
str( smps.all, n=3)
head(smps.all,n=3)
is.even <- function(x) return(!x%%2)
var.p <- function(x) {
return(sum((x-mean(x))^2 / length(x)))
}
p.even <- function(x , s,size=3) {
return(sum(is.even(x))/ s.size)
}
phat <- apply(smps.all,1,p.even)
p.even <- function(x , s.size=3) {
return(sum(is.even(x))/ s.size)
}
phat <- apply(smps.all,1,p.even)
mean(phat)
(p.p <- 0.5)
var.p(phat)
(p.p*(1-p.p)/3)
sqrt(var.p(phat))
# 5-4
set.seed(9)
n <- 10
x <- 1:100
y <- seq(-3,3,by=0.01)
smps <- matrix(rnorm(n * length(x)), ncol = n)
xbar <- apply(smps, 1, mean)
se <- 1 / sqrt(10)
alpha <- 0.05
z <- qnorm(1 - alpha/2)
ll <- xbar - z * se
ul <- xbar + z * se
plot(y,type="n")
abline(h=0,col="red")
1.c <- rep(NA, length(x))
l.c <- rep(NA, length(x))
l.c <- ifelse(ll * ul >0 , "red", "black")
arrows(1:length(x), ll, 1:length(x),ul, code = 3)
plot(y,type="n",xlim=c(1,100), ylim=c(1.5,1.5))
abline(h=0,col="red")
l.c <- rep(NA, length(x))
l.c <- ifelse(ll * ul >0 , "red", "black")
arrows(1:length(x), ll, 1:length(x),ul, code = 3)
plot(y,type="n",xlim=c(1,100), ylim=c(-1.5,1.5))
abline(h=0,col="red")
l.c <- rep(NA, length(x))
l.c <- ifelse(ll * ul >0 , "red", "black")
arrows(1:length(x), ll, 1:length(x),ul, code = 3)
par(mfrow=c(1,1))
plot(y,type="n",xlim=c(1,100), ylim=c(-1.5,1.5))
abline(h=0,col="red")
l.c <- rep(NA, length(x))
l.c <- ifelse(ll * ul >0 , "red", "black")
arrows(1:length(x), ll, 1:length(x),ul, code = 3)
plot(y,type="l",xlim=c(1,100), ylim=c(-1.5,1.5))
abline(h=0,col="red")
l.c <- rep(NA, length(x))
l.c <- ifelse(ll * ul > 0 , "red", "black")
arrows(1:length(x), ll, 1:length(x),ul, code = 3)
# 5-5
ci.t <- function(x,alpha=0.05) {
n <- length(smp)
m <- mean(x)
s <- sd(x)
t <- qt(1-(alpha/2),df=n-1)
ll <- m - t * (s / sqrt(n))
ul <- m + t * (s / sqrt(n))
ci <- c(1-alpha, ll, m, ul)
names(ci) <- c("Confi","LO","UP")
return(ci)
}
smp <- c(520,489,481,512,515,542,520,518,527,526)
ci.t(smp)
ci.t(smp,0.1)
names(ci) <- c("Confi","LO","mean","UP")
# 5-5
ci.t <- function(x,alpha=0.05) {
n <- length(smp)
m <- mean(x)
s <- sd(x)
t <- qt(1-(alpha/2),df=n-1)
ll <- m - t * (s / sqrt(n))
ul <- m + t * (s / sqrt(n))
ci <- c(1-alpha, ll, m, ul)
names(ci) <- c("Confi","LO","mean","UP")
return(ci)
}
smp <- c(520,489,481,512,515,542,520,518,527,526)
ci.t(smp)
ci.t(smp,0.1)
pt(0.727,14)
30*59
hf <- read.table("http://www.randomservices.org/random/data/Galton.txt",header = T,stringAsFactors =FALSE)
hf <- read.table("http://www.randomservices.org/random/data/Galton.txt",header = T, stringsAsFactors = FALSE)
hf$Gender <- factor(hf$Gender, levels = c("M","F"))
hf.son <- subset(hf, Gender=="M")
hf.son <- hf.son[c("Father","Height")]
f.mean <- mean(hf.son$Father)
s.mean <- mean(hf.son$Height)
con.num <- sum((hf.son$Father-f.mean) * (hf.son$Height- s.mean))
cov.xy <- cov.num / (nrow(hf.son) -1 )
con.num <- sum((hf.son$Father-f.mean) * (hf.son$Height- s.mean))
cov.xy <- cov.num / (nrow(hf.son) -1 )
cov.num <- sum((hf.son$Father-f.mean) * (hf.son$Height- s.mean))
cov.xy <- cov.num / (nrow(hf.son) -1 )
cov(hf.son$Father, hf.son$Height)
r.xy <- cov.xy / (sd(hf.son$Father) * sd(hf.son$Height))
cor(hf.son$Father,hf.son$Height)
plot(hf$Height, hf$Father)
out <- lm(Height ~ Father, data = hf.son)
summary(out)
women
plot(weight ~ height, data = women)
fit <- lm(weight ~ height, data = women)
abline(fit, col="red", lwd=2)
summary(fit)
# ch09-4
state.x77
states <- as.data.frame(state.x77[,c("Murder", "Population", "Illiteracy", "Income","Forest")])
states <- as.data.frame(state.x77[,c( "Murder", "Population", "Illiteracy", "Income","Forest" )])
states <- as.data.frame(state.x77[,c( "Murder", "Population",
"Illiteracy", "Income","Forest" )])
install.packages("leaps")
father <- c(150,160,170,180,190)
son <-  c(176,179,182,181,185)
data1 <- c(father, son)
data1
data1 <- data.frame(father, son)
data1
hf <- read.table("http://www.randomservices.org/random/data/Galton.txt", header = T, stringsAsFactors = F)
hf
rm(hf)
out1 <- lm(father ~ son, data = data1)
summary(out1)
out1 <- lm(son ~ father, data = data1)
summary(out1)
mean.x <- mean(data1$father)
mean.y <- mean(data1$son)
sxy <- sum((data1$father - mean.x)*(data1$son-mean.y))
sxx <- sum((data1$father - mean.x)^2)
b1 <- sxy / sxx
b0 <- mean.y - b1 * mean.x
b1
b0
# 그러므로 회귀직선의 방정식은 다음과 같다.
# son_height_predict <- b0 + b1 * father_height
# 식을 이용해 답을 구하면
146 + 0.2 * 165
income <- c(100,200,300,400,500)
mu <- c(30,70,85,140,197)
data2 <- data.frame(income, mu)
data2
mean.x2 <- mean(data2$income)
mean.y2 <- mean(data2$mu)
sxy2 <- sum((data2$income - mean.x2)*(data2$mu - mean.y2))
sxx2 <- sum((data2$income - mean.x2)^2)
b01 <- sxy2 / sxx2
b00 <- mean.y2 - b01 * mean.x2
b01
b00
b00 + b01 * 250
### 12-3 번문제
# mtcars 데이터셋에서 배기량(disp)에 따른 마력(hp)의 회귀식을 구하시오.
mt <- mtcars
### 12-3 번문제
# mtcars 데이터셋에서 배기량(disp)에 따른 마력(hp)의 회귀식을 구하시오.
library(dplyr)
mt <- mt %>%
select(disp, hp)
mt
mean.x3 <- mean(data3$disp)
mean.y3 <- mean(data3$hp)
data3
mean.x3 <- mean(data3$disp)
mean.y3 <- mean(data3$hp)
data3 <- mt %>%
select(disp, hp)
data3
mean.x3 <- mean(data3$disp)
mean.y3 <- mean(data3$hp)
sxy3 <- sum((data3$disp - mean.x3)*(data3$hp - mean.y3))
sxx3 <- sum((data3$hp - mean.x3)^2)
b001 <- sxy3 / sxx3
b000 <- mean.y3 - b001 * mean.x3
b001
b000
lm(son ~ father, data = data1)
lm(income ~ mu, data = data2)
lm(mu ~ income, data = data2)
lm(hp ~ disp, data = data3)
b001
lm(disp ~ hp, data = data3)
b001
b000
mt <- mtcars
data3 <- mt %>%
select(disp, hp)
data3
mean.x3 <- mean(data3$disp)
mean.y3 <- mean(data3$hp)
sxy3 <- sum((data3$disp - mean.x3)*(data3$hp - mean.y3))
sxx3 <- sum((data3$disp - mean.x3)^2)
b001 <- sxy3 / sxx3
b000 <- mean.y3 - b001 * mean.x3
lm(disp ~ hp, data = data3)
b001
b000
lm(hp ~ disp, data = data3)
library(MASS)
Boston
b <- Boston
full.model <- lm(crim~.,data=b)
backward.model <- step(full.model,direction="backward")
summary(backward.model)
# Forward Regression ----------------------------------------------------------------------------------------
min.model <- lm(crim~1,data=b)
# Forward selection을 하기 위해서는 대상이 되는 변수들이 어떤 것인지 step() 함수에 알려주어야 한다.
# scope 인수에 변수들을 알려주고 장황한 출력을 피하기 위해 trace=0을 추가했다.
fwd.model <- step(min.model,direction="forward",
scope=(crim ~ dis + rad + nox + zn + medv + black))
fwd.model <- step(min.model,direction="forward",
scope=(crim ~ dis + rad + nox + zn + medv + black),trace=0)
summary(fwd.model)
# BIC 값으로 모델을 선택하는 방법
library(leaps)
subsets <- regsubsets(crim~., data=b,
method = "seqrep", nbest = 4)
summary(subsets)
plot(subsets)
subsets <- regsubsets(crim~., data=b,
method = "exhaustive", nbest = 4)
summary(subsets)
plot(subsets)
subsets <- regsubsets(crim~., data=b,
method = "seqrep", nbest = 4)
summary(subsets)
plot(subsets)
subsets <- regsubsets(crim~., data=b,
method = "exhaustive", nbest = 4)
summary(subsets)
plot(subsets)
log_data <- read.csv("http://stats.idre.ucla.edu/stat/data/binary.csv")
str(log_data)
log_data$rank <- as.factor(log_data$rank)
str(log_data)
train <- data[1:200]
test <- data[201:400]
train <- log.data[1:200]
test <- log.data[201:400]
train <- log_data[1:200]
test <- log_data[201:400]
log_data <- read.csv("http://stats.idre.ucla.edu/stat/data/binary.csv")
log_data$rank <- as.factor(log_data$rank)
str(log_data)
train <- log_data[1:200]
test <- log_data[201:400]
# 3. Polynomial Regression (다항회귀-곡선형태) -------------------------------------------------------------------------
str(women) # height(inch), weight(lbs)
# 신장에 따른 몸무게 - liner model
plot(weight ~ height, data=women) # 실제로는 곡선형태
fit <- lm(weight ~ height, data=women) # liner model
abline(fit, col="red")
summary(fit)
par(mfrow = c(2,2))
plot(fit)
par(mfrow = c(1,1))
# 신장에 따른 몸무게 - polynomial model (2차식)
fit2 <- lm(weight ~ height + I(height^2), data=women)
plot(weight ~ height, data=women)
lines(women$height, fitted(fit2), col="green") # poly
abline(fit, col="red") # liner
summary(fit2)
par(mfrow=c(2,2))
plot(fit2)
fit <- lm(crim ~ medv, data=b) # liner model
b <- Boston
fit <- lm(crim ~ medv, data=b) # liner model
abline(fit, col="red")
summary(fit)
full.model <- lm(crim~.,data=b)
backward.model <- step(full.model,direction="backward")
fit <- lm(crim ~ zn + nox + dis + rad + ptratio + black + lstat + medv, data=b) # liner model
abline(fit, col="red")
summary(fit)
full.model <- lm(crim~.,data=b)
backward.model <- step(full.model,direction="backward")
summary(backward.model)
# Forward Regression
min.model <- lm(crim~1,data=b)
fwd.model <- step(min.model,direction="forward",
scope=(crim ~ dis + rad + nox + zn + medv + black))
fwd.model <- step(min.model,direction="forward",
scope=(crim ~ dis + rad + nox + zn + medv + black),trace=0)
summary(fwd.model)
abline(fit, col="red")
summary(fwd.model)
fit <- lm(crim ~ rad, data=b)
abline(fit, col="red")
summary(fit)
par(mfrow = c(2,2))
plot(fit)
# 1차식 (crim ~ dis)
fit_d <- lm(crim ~ dis, data=b)
abline(fit_d, col="red")
summary(fit_d)
par(mfrow = c(2,2))
plot(fit_d)
# 1차식 (crim ~ medv)
fit_m <- lm(crim ~ medv, data=b)
abline(fit_m, col="red")
summary(fit_m)
par(mfrow = c(2,2))
plot(fit_m)
fit_r <- lm(crim ~ rad, data=b)
abline(fit_r, col="red")
summary(fit_r)
par(mfrow = c(2,2))
plot(fit_r)
plot(fit_d)
plot(fit_m)
fit2_r <- lm(crim ~ rad + I(rad^2), data=b)
plot(crim ~ rad, data=b)
summary(fit2_r)
par(mfrow=c(2,2))
plot(fit2_r)
fit2_d <- lm(crim ~ dis + I(dis^2), data=b)
summary(fit2_d)
par(mfrow=c(2,2))
plot(fit2_d)
fit2_m <- lm(crim ~ medv + I(medv^2), data=b)
summary(fit2_m)
par(mfrow=c(2,2))
plot(fit2_m)
plot(fit_r)
plot(fit_d)
summary(fit_m)
par(mfrow = c(2,2))
plot(fit_m)
library(leaps)
subsets <- regsubsets(crim~., data=b,
method = "seqrep", nbest = 4)
subsets1 <- regsubsets(crim~., data=b,
method = "seqrep", nbest = 4)
summary(subsets1)
plot(subsets1)
par(mfrow=c(1,2))
subsets1 <- regsubsets(crim~., data=b,
method = "seqrep", nbest = 4)
summary(subsets1)
plot(subsets1)
subsets2 <- regsubsets(crim~., data=b,
method = "exhaustive", nbest = 4)
summary(subsets2)
plot(subsets2)
a <- summary(subsets2)$bic
a
plot(a,type = "b")
which.min(a)
coef(a)
coef(subsets2,9)
